{"version":3,"sources":["../../Prototypes/basic_prototypes.js"],"names":[],"mappings":";;AAAA,MAAM,QAAQ,QAAR,CAAN;;AAEA,SAAS,KAAT,GAAgB;AACd,OAAK,KAAL,GAAa,KAAb;AACA,OAAK,UAAL,GAAkB,YAAU;AAC1B,WAAO,KAAK,KAAZ;AACD,GAFD;AAGD;;AAED,MAAM,SAAN,CAAgB,UAAhB,GAA6B,YAAU;AACrC,SAAO,CAAC,KAAK,KAAb;AACD,CAFD;;AAIA,IAAI,SAAS,OAAb;AACA,IAAI,SAAS,IAAI,KAAJ,EAAb;AACA,QAAQ,GAAR,CAAY,UAAU,OAAO,UAAP,EAAtB;AACA,QAAQ,GAAR,CAAY,OAAO,UAAP,EAAZ;;;;;AAKA,MAAM,SAAN,CAAgB,WAAhB,GAA8B,YAAY;AACxC,SAAO,CAAP;AACD,CAFD;;AAIA,QAAQ,GAAR,CAAY,OAAO,WAAP,EAAZ;AACA,IAAI,mBAAJ;;;;;;AAMA,IAAI,MAAM,IAAI,MAAJ,EAAV;;;AAGA,OAAO,SAAP,CAAiB,QAAjB,GAA4B,KAA5B;;AAEA,QAAQ,GAAR,CAAY,IAAI,QAAJ,IAAgB,SAA5B;AACA,QAAQ,GAAR,CAAY,IAAI,QAAJ,KAAiB,OAAO,SAAP,CAAiB,QAA9C;;AAEA,QAAQ,GAAR,CAAY,OAAO,QAAnB;AACA,QAAQ,GAAR,CAAY,OAAO,SAAP,CAAiB,QAAjB,KAA8B,OAAO,QAAjD;;AAEA,QAAQ,GAAR,CAAY,OAAO,SAAP,CAAiB,QAAjB,KAA8B,OAAO,QAArC,IACP,OAAO,QAAP,KAAoB,IAAI,QADjB,IAEP,IAAI,QAAJ,MAAkB,IAAI,SAAJ,IAAiB,IAAI,SAAJ,CAAc,QAAjD,CAFL;;;AAKA,IAAI,mBAAJ;;;;AAIA,OAAO,QAAP,GAAkB,CAAlB;AACA,QAAQ,GAAR,CAAY,OAAO,QAAnB;AACA,QAAQ,GAAR,CAAY,OAAO,SAAP,CAAiB,QAA7B;AACA,QAAQ,GAAR,CAAY,IAAI,QAAhB;;;AAGA,QAAQ,GAAR,CAAY,OAAO,SAAP,CAAiB,QAAjB,KAA8B,OAAO,QAArC,IACP,OAAO,QAAP,KAAoB,IAAI,QADjB,IAEP,IAAI,QAAJ,MAAkB,IAAI,SAAJ,IAAiB,IAAI,SAAJ,CAAc,QAAjD,CAFL;AAGA,IAAI,mBAAJ;;;AAGA,OAAO,SAAP,CAAiB,QAAjB,GAA4B,QAA5B;AACA,QAAQ,GAAR,CAAY,OAAO,QAAnB;AACA,QAAQ,GAAR,CAAY,OAAO,SAAP,CAAiB,QAA7B;AACA,QAAQ,GAAR,CAAY,IAAI,QAAhB;;;;;AAKA,IAAI,mBAAJ;;;AAGA,QAAQ,GAAR,CAAY,IAAI,WAAhB;AACA,QAAQ,GAAR,CAAY,IAAI,WAAJ,CAAgB,SAA5B","file":"basic_prototypes.js","sourcesContent":["lib = require('../lib');\n\nfunction Ninja(){\n  this.swung = false;\n  this.swingSword = function(){\n    return this.swung;\n  };\n}\n\nNinja.prototype.swingSword = function(){\n  return !this.swung;\n};\n\nvar ninja1 = Ninja();\nvar ninja2 = new Ninja();\nconsole.log(ninja1 && ninja1.swingSword());\nconsole.log(ninja2.swingSword());\n\n// Does not have to be in order, prototypes will be\n// 'attached', rather than 'added', so even after creation\n// of the object, you can magically attach properties\nNinja.prototype.doubleSwing = function () {\n  return 2;\n};\n\nconsole.log(ninja2.doubleSwing());\nlib.printHorizontalRule();\n\n// This is pretty much what the engine does to fetch a property on a JS object:\n// 1. It searches the object itself to see if it contains the property, if not\n// 2. It searches the prototype of the object to see if it contains the property, if not\n// 3. Return undefined.\nvar obj = new Object();\n// Notice how the prototype is set on the Constructor, not the object itself\n// The prototype of the object is actually undefined\nObject.prototype.property = 'sai';\n// Similarly, look at how we call the prototype on the constructor and it prints out the value.\nconsole.log(obj.property || undefined);\nconsole.log(obj.property === Object.prototype.property);\n// Surpriseee!!! You can also access the property *directly* on the constructor.\nconsole.log(Object.property);\nconsole.log(Object.prototype.property === Object.property);\n// First time I am actually using `===` more than once in a statement haha. EDIT: Apparently, doesn't work as intended\nconsole.log(Object.prototype.property === Object.property\n  && Object.property === obj.property\n  && obj.property !== (obj.prototype && obj.prototype.property));\n// Need to figure why this did not work, haha\n// console.log(Object.prototype.property === Object.property === obj.property !== (obj.prototype && obj.prototype.property));\nlib.printHorizontalRule();\n\n// let us change some values\n// whoops, no change to the other values :O\nObject.property = 1;\nconsole.log(Object.property);\nconsole.log(Object.prototype.property);\nconsole.log(obj.property);\n\n// But wait, what?? EDIT: nvm, just my bad `===`\nconsole.log(Object.prototype.property === Object.property\n  && Object.property === obj.property\n  && obj.property !== (obj.prototype && obj.prototype.property));\nlib.printHorizontalRule();\n\n// What if we change the prototype instead?\nObject.prototype.property = 'maybe?';\nconsole.log(Object.property);\nconsole.log(Object.prototype.property);\nconsole.log(obj.property);\n\n// So despite both `.prototype.property` and `.property` making changes to the\n// Constructor, they do not update each other. But the object instance gets the changes.\n\nlib.printHorizontalRule();\n// Also, the `.constructor` property also exists for constructed objects.\n// See how the property is actually set to `1` here\nconsole.log(obj.constructor);\nconsole.log(obj.constructor.prototype);"]}