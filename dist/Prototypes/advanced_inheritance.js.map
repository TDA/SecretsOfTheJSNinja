{"version":3,"sources":["../../Prototypes/advanced_inheritance.js"],"names":[],"mappings":";;AAAA,IAAI,MAAM,QAAQ,QAAR,CAAV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA,CAAC,YAAY;AACX;;AAEA,MAAI,eAAe,KAAnB;AACA,MAAI,eAAe,YAAnB;;AAEA,WAAS,UAAT,CAAoB,EAApB,EAAwB;AACtB,WAAO,OAAO,EAAP,KAAc,UAArB;AACD;;AAED,WAAS,kBAAT,GAA8B;AAC5B,WAAO,aAAa,IAAb,CAAkB,WAAW,IAAX,CAAlB,CAAP;AACD;;AAED,SAAO,QAAP,GAAkB,UAAU,YAAV,EAAwB;AACxC,QAAI,SAAS,KAAK,SAAlB;;AAEA,mBAAe,IAAf;AACA,QAAI,QAAQ,IAAI,IAAJ,EAAZ;AACA,mBAAe,KAAf;;AAEA,SAAK,IAAI,UAAT,IAAuB,YAAvB,EAAqC;;AAEnC,UAAI,WAAW,aAAa,UAAb,CAAX,KAAwC,WAAW,OAAO,UAAP,CAAX,CAAxC,IAA0E,mBAAmB,aAAa,UAAb,CAAnB,CAA9E,EAA4H;;;AAG3H,OAHD,MAGO;;AAEL,gBAAM,UAAN,IAAoB,aAAa,UAAb,CAApB;AACD;AACF;AACF,GAjBD;AAkBD,CAhCD","file":"advanced_inheritance.js","sourcesContent":["var lib = require('../lib');\n\n// Let's simulate traditional inheritance with JS using prototypes\n// This will allow us to mimic something very close to React.createClass({x: y}); syntax.\n\n// e.g. here will be uncommented once we finish writing the basic struture\n// var Person = Object.subClass({\n//   init: function(isDancing) {\n//     this.dancing = isDancing;\n//   },\n//   dance: function() {\n//     return this.dancing;\n//   }\n// });\n\n// var Ninja = Person.subClass({\n//   init: function() {\n//     this._super(false);\n//   },\n//   dance: function() {\n//     // Ninja-specific stuff here\n//     return this._super();\n//   },\n//   swingSword: function() {\n//     return true;\n//   }\n// });\n\n\n// All of these should pass for us when our code is done\n// var person = new Person(true);\n// lib.assertCommandLine(person.dance(), \"The person is dancing.\");\n// var ninja = new Ninja();\n// lib.assertCommandLine(ninja.swingSword(), \"The sword is swinging.\");\n// lib.assertCommandLine(!ninja.dance(), \"The ninja is not dancing.\");\n// lib.assertCommandLine(person instanceof Person, \"Person is a Person.\");\n// lib.assertCommandLine(ninja instanceof Ninja && ninja instanceof Person, \"Ninja is a Ninja and a Person.\");\n\n(function () {\n  'use strict';\n\n  let initializing = false;\n  let superPattern = /\\b_super\\b/;\n  \n  function isFunction(fn) {\n    return typeof fn === 'function';\n  }\n\n  function functionCallsSuper() {\n    return superPattern.test(properties[name]);\n  }\n\n  Object.subclass = function (classMembers) {\n    let _super = this.prototype;\n\n    initializing = true;\n    let proto = new this();\n    initializing = false;\n\n    for (let memberName in classMembers) {\n      // check if this is a function that makes a call to a `_super()`\n      if (isFunction(classMembers[memberName]) && isFunction(_super[memberName]) && functionCallsSuper(classMembers[memberName])) {\n        // we need special handling here, this calls super, so we need to execute super first and then set this to execute after that\n        // Pretty much simulating `super` keyword in other languages (and ES6+) :)\n      } else {\n        // Just copy the member\n        proto[memberName] = classMembers[memberName];\n      }\n    }\n  };\n})();\n"]}