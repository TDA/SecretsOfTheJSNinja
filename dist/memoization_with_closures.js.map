{"version":3,"sources":["../memoization_with_closures.js"],"names":[],"mappings":"AAAA;;;;AAGA,SAAS,SAAT,CAAmB,QAAnB,GAA8B,UAAS,GAAT,EAAa;AACzC,OAAK,OAAL,GAAe,KAAK,OAAL,IAAgB,EAA/B;AACA,SAAO,KAAK,OAAL,CAAa,GAAb,MAAsB,SAAtB,GACL,KAAK,OAAL,CAAa,GAAb,CADK,GAEL,KAAK,OAAL,CAAa,GAAb,IAAoB,KAAK,KAAL,CAAW,IAAX,EAAiB,SAAjB,CAFtB;AAGD,CALD;;;AAQA,SAAS,YAAT,CAAsB,GAAtB,EAA2B;AACzB,MAAI,QAAQ,QAAQ,CAApB;AACA,OAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,IAAL,CAAU,GAAV,CAApB,EAAoC,GAApC,EAAyC;AACvC,QAAI,MAAM,CAAN,KAAY,CAAhB,EAAmB;AACjB,cAAQ,KAAR;AACA;AACD;AACF;AACD,SAAO,KAAP;AACD;;AAED,QAAQ,GAAR,CAAY,aAAa,CAAb,CAAZ;AACA,QAAQ,GAAR,CAAY,aAAa,EAAb,CAAZ;;;;;;AAMA,QAAQ,GAAR,CAAY,aAAa,QAAb,CAAsB,CAAtB,CAAZ;AACA,QAAQ,GAAR,CAAY,aAAa,QAAb,CAAsB,EAAtB,CAAZ;AACA,QAAQ,GAAR,CAAY,aAAa,QAAb,CAAsB,OAAlC;AACA,QAAQ,GAAR,CAAY,aAAa,OAAzB;;;;AAIA,SAAS,SAAT,CAAmB,OAAnB,GAA6B,YAAY;AACvC,MAAI,KAAK,IAAT;;;;;AAKA,SAAO,YAAY;AACjB,WAAO,GAAG,QAAH,CAAY,KAAZ,CAAkB,EAAlB,EAAsB,SAAtB,CAAP;AACD,GAFD;AAGD,CATD;AAUA,IAAI,kBAAkB,aAAa,OAAb,EAAtB","file":"memoization_with_closures.js","sourcesContent":["'use strict';\n\n// Let's write a memo function for all functions\nFunction.prototype.memoized = function(key){\n  this._values = this._values || {};\n  return this._values[key] !== undefined ?\n    this._values[key] :\n    this._values[key] = this.apply(this, arguments);\n};\n\n// Regular isPrime that has no memo\nfunction isPrimePlain(num) {\n  let prime = num !== 1;\n  for (let i = 2; i < Math.sqrt(num); i++) {\n    if (num % i === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n}\n\nconsole.log(isPrimePlain(5));\nconsole.log(isPrimePlain(55));\n\n// By overriding the function prototype, we can add our own\n// memoization to an existing function, two problems with this though:\n// 1. Caller needs to know this new method\n// 2. The cache is stored on the original method, potentially confusing noobs who call another function\nconsole.log(isPrimePlain.memoized(5));\nconsole.log(isPrimePlain.memoized(55));\nconsole.log(isPrimePlain.memoized._values);\nconsole.log(isPrimePlain._values);\n\n// To fix this, lets wrap isPrimePlain in a closure, bind the scope\n// to memoized(), and call it as though nothing extra is happening\nFunction.prototype.memoize = function () {\n  var fn = this;\n  // Pretty much return the function wrapped with a call to the memoized() version\n  // Look at how the closure enables us to do something that is otherwise not very\n  // straightforward. It feels like all we are doing is calling the function wrapped\n  // in another, but the context binding is essential and only possible due to closures.\n  return function () {\n    return fn.memoized.apply(fn, arguments)\n  }\n};\nvar isPrimeMemoized = isPrimePlain.memoize();"]}