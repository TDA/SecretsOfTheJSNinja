{"version":3,"sources":["../memoization_with_closures.js"],"names":[],"mappings":"AAAA;;;;AAGA,SAAS,SAAT,CAAmB,QAAnB,GAA8B,UAAS,GAAT,EAAa;AACzC,OAAK,OAAL,GAAe,KAAK,OAAL,IAAgB,EAA/B;AACA,SAAO,KAAK,OAAL,CAAa,GAAb,MAAsB,SAAtB,GACL,KAAK,OAAL,CAAa,GAAb,CADK,GAEL,KAAK,OAAL,CAAa,GAAb,IAAoB,KAAK,KAAL,CAAW,IAAX,EAAiB,SAAjB,CAFtB;AAGD,CALD;;;AAQA,SAAS,WAAT,CAAqB,GAArB,EAA0B;AACxB,MAAI,QAAQ,QAAQ,CAApB;AACA,OAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,IAAL,CAAU,GAAV,CAApB,EAAoC,GAApC,EAAyC;AACvC,QAAI,MAAM,CAAN,KAAY,CAAhB,EAAmB;AACjB,cAAQ,KAAR;AACA;AACD;AACF;AACD,SAAO,KAAP;AACD;;AAED,QAAQ,GAAR,CAAY,YAAY,CAAZ,CAAZ;AACA,QAAQ,GAAR,CAAY,YAAY,EAAZ,CAAZ;;;;;;AAMA,QAAQ,GAAR,CAAY,YAAY,QAAZ,CAAqB,CAArB,CAAZ;AACA,QAAQ,GAAR,CAAY,YAAY,QAAZ,CAAqB,EAArB,CAAZ;AACA,QAAQ,GAAR,CAAY,YAAY,QAAZ,CAAqB,OAAjC;AACA,QAAQ,GAAR,CAAY,YAAY,OAAxB","file":"memoization_with_closures.js","sourcesContent":["'use strict';\n\n// Let's write a memo function for all functions\nFunction.prototype.memoized = function(key){\n  this._values = this._values || {};\n  return this._values[key] !== undefined ?\n    this._values[key] :\n    this._values[key] = this.apply(this, arguments);\n};\n\n// Regular isPrime that has no memo\nfunction isPrimeMemo(num) {\n  let prime = num !== 1;\n  for (let i = 2; i < Math.sqrt(num); i++) {\n    if (num % i === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n}\n\nconsole.log(isPrimeMemo(5));\nconsole.log(isPrimeMemo(55));\n\n// By overriding the function prototype, we can add our own\n// memoization to an existing function, two problems with this though:\n// 1. Caller needs to know this new method\n// 2. The cache is stored on the original method, potentially confusing noobs who call another function\nconsole.log(isPrimeMemo.memoized(5));\nconsole.log(isPrimeMemo.memoized(55));\nconsole.log(isPrimeMemo.memoized._values);\nconsole.log(isPrimeMemo._values);"]}