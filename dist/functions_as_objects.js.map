{"version":3,"sources":["../functions_as_objects.js"],"names":[],"mappings":";;;;;;AAMA;;AAEA,IAAI,QAAQ;AACV,UAAQ,CADE;AAEV,SAAO,EAFG;AAGV,OAAK,aAAU,EAAV,EAAc;AACjB,QAAG,CAAC,GAAG,EAAP,EAAW;AACT,SAAG,EAAH,GAAQ,KAAK,MAAL,EAAR;;;;;;;AAOA,aAAO,CAAC,EAAG,KAAK,KAAL,CAAW,GAAG,EAAd,IAAoB,EAAvB,CAAR;AACD,KATD,MASO;AACL,aAAO,KAAP;AACD;AACF;AAhBS,CAAZ;;AAmBA,SAAS,KAAT,GAAiB;AACf,SAAO,CAAP;AACD;;AAED,QAAQ,GAAR,CAAY,MAAM,GAAN,CAAU,KAAV,CAAZ;AACA,QAAQ,GAAR,CAAY,MAAM,GAAN,CAAU,KAAV,CAAZ;AACA,QAAQ,GAAR,CAAY,KAAZ;;AAEA,SAAS,MAAT,GAAkB;AAChB,SAAO,CAAP;AACD;;AAED,QAAQ,GAAR,CAAY,MAAM,GAAN,CAAU,MAAV,CAAZ;AACA,QAAQ,GAAR,CAAY,KAAZ;;;;;AAMA,SAAS,OAAT,CAAiB,CAAjB,EAAoB;AAClB,MAAI,CAAC,QAAQ,KAAb,EAAoB;AAClB,YAAQ,KAAR,GAAgB,EAAhB;AACD;AACD,MAAI,QAAQ,KAAR,CAAc,CAAd,CAAJ,EAAsB;AACpB,WAAO,QAAQ,KAAR,CAAc,CAAd,CAAP;AACD;AACD,MAAI,QAAQ,MAAM,CAAlB;AACA,OAAK,IAAI,IAAI,CAAb,EAAgB,KAAK,KAAK,IAAL,CAAU,CAAV,CAArB,EAAmC,GAAnC,EAAwC;AACtC,QAAI,IAAI,CAAJ,KAAU,CAAd,EAAiB;AACf,cAAQ,KAAR;AACD;AACF;AACD,SAAO,QAAQ,KAAR,CAAc,CAAd,IAAmB,KAA1B;AACD;;AAED,QAAQ,GAAR,CAAY,QAAQ,CAAR,CAAZ;AACA,QAAQ,GAAR,CAAY,QAAQ,CAAR,CAAZ;AACA,QAAQ,GAAR,CAAY,QAAQ,CAAR,CAAZ;AACA,QAAQ,GAAR,CAAY,QAAQ,KAApB;;AAEA,SAAS,mBAAT,CAA6B,QAA7B,EAAuC;AACrC,UAAQ,GAAR,CAAY,QAAZ;AACA,MAAI,CAAE,oBAAoB,KAA1B,EAAiC;AAC/B,wBAAoB,KAApB,GAA4B,EAA5B;AACD;AACD,UAAQ,GAAR,CAAY,oBAAoB,KAAhC;;AAEA,SAAO,oBAAoB,KAApB,CAA0B,QAA1B,IAAsC,oBAAoB,KAApB,CAA0B,QAA1B,KAAuC,SAAS,gBAAT,CAA0B,QAA1B,CAApF;AACD","file":"functions_as_objects.js","sourcesContent":["/**\n * Created by schandramouli on 7/16/17.\n */\n\n// This is such a beautiful example, not only does it explain the quirks of JS,\n// but also uses CS fundamentals like Hashmaps and stuff <3\n'use strict';\n\nvar store = {\n  nextId: 1,\n  cache: {},\n  add: function (fn) {\n    if(!fn.id) {\n      fn.id = this.nextId++;\n      // this is assignment and verifying if assignment passes\n      // its definitely harder to read tho haha :)\n      // is equivalent to doing Boolean(expr)\n      // but not equivalent to new Boolean(expr), as that is an object\n      // Objects are truthy even if they contain falsy values\n      // !! false === Boolean(false) !== new Boolean(false)\n      return !! (this.cache[fn.id] = fn);\n    } else {\n      return false;\n    }\n  }\n};\n\nfunction ninja() {\n  return 1;\n}\n\nconsole.log(store.add(ninja));\nconsole.log(store.add(ninja));\nconsole.log(store);\n\nfunction ninja2() {\n  return 2;\n}\n\nconsole.log(store.add(ninja2));\nconsole.log(store);\n\n\n// This is memoization function that has a cache and uses that to store\n// the previously computed sums, pretty straightforward just like other languages\n\nfunction isPrime(n) {\n  if (!isPrime.cache) {\n    isPrime.cache = {};\n  }\n  if (isPrime.cache[n]) {\n    return isPrime.cache[n];\n  }\n  let prime = n !== 1;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      prime = false;\n    }\n  }\n  return isPrime.cache[n] = prime;\n}\n\nconsole.log(isPrime(4));\nconsole.log(isPrime(9));\nconsole.log(isPrime(5));\nconsole.log(isPrime.cache);\n\nfunction getElementsMemoized(selector) {\n  console.log(selector);\n  if (! getElementsMemoized.cache) {\n    getElementsMemoized.cache = {};\n  }\n  console.log(getElementsMemoized.cache);\n  // Missing Ruby's ||= here haha\n  return getElementsMemoized.cache[selector] = getElementsMemoized.cache[selector] || document.querySelectorAll(selector);\n}"]}